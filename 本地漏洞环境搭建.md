由于计划内的漏洞类型在Hello-Java-Sec靶场中没有，所以决定自己搭建漏洞环境，为了方便还是放在Hello-Java-Sec的代码中。

# QLExpress注入
QLExpress是阿里巴巴开源的一款动态脚本引擎解析工具，该脚本引擎在开发人员使用不当的情况下，容易造成表达式注入漏洞，形成 RCE 高危漏洞。此次QLExpress的漏洞环境本地搭建参考了[《浅析QLExpress脚本引擎表达式注入漏洞》](https://blog.csdn.net/weixin_39190897/article/details/135072564)，为了方便，代码就直接放在Hello-Java-Sec靶场的代码里。完整代码如下：

```java
import com.ql.util.express.config.QLExpressRunStrategy;
import io.swagger.annotations.Api;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import com.ql.util.express.ExpressRunner;

@Api("QLExpress表达式注入")
@RestController
@RequestMapping("/vulnapi/QLExpress")
public class QLExpress {
    @RequestMapping("/vuln")
    public String vulnQL(String expr) {
        try {
            ExpressRunner runner = new ExpressRunner();
            Object result = runner.execute(expr, null, null, false, false);
            return "Result: " + result;
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }

    // 黑名单
    @RequestMapping("/safeBlacklist")
    public String safeBlacklist(String expr) {
        try {
            QLExpressRunStrategy.setForbidInvokeSecurityRiskMethods(true);
            Object result = new ExpressRunner().execute(expr, null, null, false, false);
            return "Result: " + result;
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }

    // 白名单
    @RequestMapping("/safeWhitelist")
    public String safeWhitelist(String expr) {
        try {
            QLExpressRunStrategy.setForbidInvokeSecurityRiskMethods(true);
            QLExpressRunStrategy.addSecureMethod(Runtime.class, "getRuntime");
            QLExpressRunStrategy.addSecureMethod(Runtime.class, "exec");
            Object result = new ExpressRunner().execute(expr, null, null, false, false);
            return "Result: " + result;
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }

    // 沙箱模式
    @RequestMapping("/safeSandbox")
    public String safeSandbox(String expr) {
        try {
            QLExpressRunStrategy.setSandBoxMode(true);
            Object result = new ExpressRunner().execute(expr, null, null, false, false);
            return "Result: " + result;
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }
}
```

首先测试下`/vuln`接口，PoC是`http://127.0.0.1:8888/vulnapi/QLExpress/vuln?expr=java.lang.Runtime.getRuntime().exec(%27calc.exe%27)`：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758180234479-1c7f77e2-7059-4a3a-8cd0-3f30233c0c8d.png)

官方提供了配置代码执行的黑白名单、开启沙箱的多级别安全功能。这几种配置都是一句话的事，首先看看黑名单。QLExpess目前默认添加的黑名单有：

```plain
java.lang.System.exit
java.lang.Runtime.exec
java.lang.ProcessBuilder.start
java.lang.reflect.Method.invoke
java.lang.reflect.Class.forName
java.lang.reflect.ClassLoader.loadClass
java.lang.reflect.ClassLoader.findClass
```

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758179311308-6b295eb4-a1ef-4ac0-ba3e-121b6e47c770.png)

可以看到刚刚的PoC已经无法生效：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758180299714-d734ca8b-dacf-4379-9931-7c7c77f287a1.png)

下面看看白名单：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758179346718-0819be0e-e611-4220-b12f-626e60e63218.png)

PoC又能执行：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758180324816-2be0d0de-1cf0-4cee-ab1e-0eedd7ec5b82.png)

如果只想关闭QLExpress和Java应用的自由交互，就开启沙箱模式：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758180367224-4ce30c6d-ad46-4c6a-b7ae-39fcb1886260.png)

可以看到PoC无法生效：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758180414379-4fef86df-139a-4ad2-aeea-32b069c3960c.png)

# ZipSlip
> ZipSlip是一种利用压缩文件中的路径遍历漏洞的攻击方式。攻击者可以通过构造一个ZIP文件，其中包含类似于 `../` 或绝对路径（如 `/etc/passwd`）的文件路径。当解压这些文件时，系统会错误地将文件写入不应访问的目录，可能导致文件覆盖、权限提升或其他恶意操作。
>

漏洞演示代码如下：

```java
import io.swagger.annotations.Api;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.io.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.nio.file.*;

@Api("ZipSlip")
@RestController
@RequestMapping("/vulnapi/ZipSlip")
public class ZipSlip {

    @RequestMapping("/vuln")
    public String vulnZipSlip(String zipFilePath, String destination) {
        try {
            File zipFile = new File(zipFilePath);
            ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                File destFile = new File(destination, entry.getName());
                if (entry.isDirectory()) {
                    destFile.mkdirs();
                } else {
                    FileOutputStream fos = new FileOutputStream(destFile);
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = zis.read(buffer)) > 0) {
                        fos.write(buffer, 0, length);
                    }
                    fos.close();
                }
                zis.closeEntry();
            }
            zis.close();
            return "Zip 文件提取成功!";
        } catch (IOException e) {
            return "错误: " + e.getMessage();
        }
    }

    @RequestMapping("/safe")
    public String safeZipSlip(String zipFilePath, String destination) {
        try {
            File zipFile = new File(zipFilePath);
            ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                // 对文件名进行路径净化，防止目录遍历
                String destFileName = Paths.get(entry.getName()).getFileName().toString();
                File destFile = new File(destination, destFileName);

                // 检查路径，确保不会提取到目标目录之外
                if (!destFile.getCanonicalPath().startsWith(new File(destination).getCanonicalPath())) {
                    throw new IOException("检测到目录遍历攻击!");
                }

                if (entry.isDirectory()) {
                    destFile.mkdirs();
                } else {
                    // 安全的提取代码
                    FileOutputStream fos = new FileOutputStream(destFile);
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = zis.read(buffer)) > 0) {
                        fos.write(buffer, 0, length);
                    }
                    fos.close();
                }
                zis.closeEntry();
            }
            zis.close();
            return "Zip 文件提取成功!";
        } catch (IOException e) {
            return "错误: " + e.getMessage();
        }
    }
}
```

首先用以下代码生成一个恶意的ZIP文件：

```python
import zipfile


def zip_slip_file(output_path):
    try:
        with open("test.txt", "r") as f:
            binary = f.read()
            with zipfile.ZipFile(output_path, "w", zipfile.ZIP_DEFLATED) as zipFile:
                zipFile.writestr("malicious_dir/../../test.txt", binary)
    except Exception as e:
        print(e)


if __name__ == '__main__':
    zip_slip_file(r'test.zip')
```

`/vuln`接口没有路径净化，允许目录遍历攻击，PoC如下：

```plain
http://127.0.0.1:8888/vulnapi/ZipSlip/vuln?zipFilePath=D:/workspace/PythonProject/test.zip&destination=D:/workspace/blogs
```

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758183706213-a13bf5c1-18e3-421b-bfaf-58f0e6168101.png)

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758183725957-569db09f-1125-44b6-b5d9-783104412633.png)

可以看到`test.txt`被解压后穿越出了本来的目的地`blogs`文件夹。

为了防止这类攻击，我们可以通过检查和净化路径来实现：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758184082820-cb8fdce9-1461-4647-a8f6-dbf8410b4a05.png)

这里在解压时，使用`Paths.get(entry.getName()).getFileName().toString()`来获取文件的安全名称，而不是直接使用ZIP文件中的路径。并使用`getCanonicalPath()`方法获取文件的绝对路径，并检查提取路径是否在指定的目标目录内。

访问`http://127.0.0.1:8888/vulnapi/ZipSlip/safe?zipFilePath=D:/workspace/PythonProject/test.zip&destination=D:/workspace/blogs`，发现`test.txt`被安全解压，没有发生目录穿越。

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758184244061-9cf3afc2-6fa8-48c5-a3e6-f35e29937da6.png)

# <font style="color:rgb(31, 35, 40);">Filter过滤器认证绕过漏洞（JavaVulHunter）</font>
点击“Filter鉴权绕过”，显示“Unauthorized access”：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758194065503-15cff22d-f91f-46b2-b3be-1f9d2e2e6d57.png)

定位到对应的代码`com/sec/demo/filter/SecurityFilter.java`：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758194207005-45a8c715-42a2-48ae-acda-837bf18bc13c.png)

可以看到如果路径包含`/admin/secret`会进行AccessToken鉴权。再往前看，发现在这段if-else代码块中，`/admin/secret`的判断之前还有登录请求和前端资源请求的判断，除此之外还用了`getRequestURI()`，这个方法默认不会处理特殊字符，具体会带来的问题可以参考《[getRequestURI导致的安全问题](https://www.cnblogs.com/depycode/p/16124191.html)》。

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758267341197-fbf22772-2b3b-4a31-a4f9-ae92e9c1b70a.png)

因此可以进入AT鉴权之前的代码块以绕过AT鉴权，首先尝试通过登录请求绕过：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758267904578-f7dcd782-438b-4cda-bf91-def59ca9bb75.png)

目录穿越没有成功。应该是因为Tomcat不处理`..`，导致没有控制器能匹配`/admin/login/../secret`。

接着尝试通过前端资源请求绕过：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758268840120-21ca45f3-02b6-48bd-af68-70f509b5206c.png)

成功绕过。

针对这个漏洞，应该要调用安全函数`getServletPath()`，会自动处理http请求URL中的非法字符，包括URL解码。除此之外也可以使用强大的安全框架。

# <font style="color:rgb(31, 35, 40);">AOP注解鉴权绕过漏洞（JavaVulHunter）</font>
点击“AOP鉴权注解绕过”，显示“401 UNAUTHORIZED”：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758269096024-3b13c449-1bd0-4b7c-ae9e-59bee0d61e85.png)

定位到对应的源码，发现用到了一个自定义的鉴权注解，仅允许ADMIN用户访问：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758269207963-c1b1b1d3-ae2b-4089-9a8e-398a60261b72.png)

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758269268983-2dd72f81-b0ba-4d1c-ad02-35046df83280.png)

这个注解显示roles属性如果没有被显式指定，就是USER角色。一开始以为用户角色是存储在Cookie中的Session ID，但是没法以ADMIN身份登录来获取对应的Cookie继续替换，而且这题重在绕过，所以用户角色应该是存储在请求头（例如自定义的Roles头）:

> 根据HTTP/1.1规范（RFC 7230），HTTP头字段名称是不区分大小写的。
>

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758269884537-bb4612ff-bc03-472d-a784-a3de605ad3ad.png)

成功绕过。

针对这种情况的防护，应该从Session或Token中获取真实用户身份，而不是请求头。当然最佳实践应该是使用SpringSecurity，这样就可以把注解换成`@PreAuthorize("hasRole('ADMIN')")`这种。

# <font style="color:rgb(31, 35, 40);">Intercepter拦截器绕过漏洞（JavaVulHunter）</font>
点击“Intercepter拦截器绕过”，显示“Admin authentication failed”：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758270146179-75c48163-4a68-478c-bfc9-82cc0399be21.png)

定位到源码：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758270339461-8bb1069c-9612-47b8-bc27-45d4c76e433d.png)

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758270365883-7f8dafc7-39b3-4484-a9cd-a99cb3fbfdc0.png)

可以看到会从请求头取AuthToken进行简单校验，所以只需要抓包在请求头加上值为`secret-admin-token-123`的AuthToken即可：

![](https://cdn.nlark.com/yuque/0/2025/png/43311313/1758270468445-cd7201d7-6919-4753-be80-18a54e8ccc43.png)

成功绕过。

针对这种情况的防护，最好使用Spring Security替代自定义拦截器。

